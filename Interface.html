<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="DJ Mix Pro">
    <meta name="theme-color" content="#00d4ff">
    <meta name="description" content="Advanced DJ track mixing and recommendation system for mobile DJs">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Favicon and Icons -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%231a1a2e'/%3E%3Ccircle cx='50' cy='50' r='35' fill='none' stroke='%2300d4ff' stroke-width='4'/%3E%3Ccircle cx='50' cy='35' r='8' fill='%2300d4ff'/%3E%3Cpath d='M35 65 Q50 55 65 65' stroke='%2300d4ff' stroke-width='3' fill='none'/%3E%3Ctext x='50' y='80' text-anchor='middle' fill='%23ffffff' font-family='Arial' font-size='10'%3EDJ%3C/text%3E%3C/svg%3E">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- Preconnect to Google Fonts for faster loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <title>DJ Mix System - Professional Edition</title>
    <style>
        /* ===== RESET & BASE STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            height: 100vh;
            overflow: hidden;
            position: relative;
            -webkit-tap-highlight-color: transparent;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: auto;
        }
        
        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* ===== TOP SECTION ===== */
        .top-section {
            height: 55vh;
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
        }
        
        /* ===== FILTER BARS ===== */
        .filter-bar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 18px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            min-height: 45px;
            display: flex;
            align-items: center;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .filter-bar:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        .filter-bar.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
        }
        
        .undo-bar {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.4);
        }
        
        .undo-bar:hover {
            background: rgba(255, 107, 107, 0.3);
        }
        
        .undo-bar.active {
            background: rgba(255, 107, 107, 0.4);
            border-color: #ff6b6b;
        }
        
        .bar-label {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .bar-content {
            font-size: 16px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .undo-arrow {
            font-size: 18px;
            color: #ff6b6b;
        }
        
        .search-input {
            background: transparent;
            border: none;
            outline: none;
            color: white;
            font-size: 16px;
            width: 100%;
            font-family: inherit;
        }
        
        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* ===== ACTION CONTAINER ===== */
        .action-container {
            display: flex;
            gap: 10px;
            flex: 1;
        }
        
        .action-box {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 18px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            min-height: 45px;
            display: flex;
            align-items: center;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .action-box:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        .reset-box {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.4);
        }
        
        .reset-box:hover {
            background: rgba(255, 107, 107, 0.2);
        }
        
        .reset-box.active {
            background: rgba(255, 107, 107, 0.3);
            border-color: #ff6b6b;
        }
        
        .undo-box {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.4);
        }
        
        .undo-box:hover {
            background: rgba(0, 212, 255, 0.2);
        }
        
        .undo-box.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
        }
        
        .action-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 2px;
        }
        
        .action-content {
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .reset-icon, .undo-icon {
            font-size: 14px;
        }
        
        /* ===== BOTTOM SECTION ===== */
        .bottom-section {
            height: 45vh;
            padding: 15px;
            overflow: hidden;
        }
        
        .results-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            height: 100%;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow-y: auto;
            padding: 20px;
        }
        
        .results-header {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #00d4ff;
        }
        
        /* ===== TRACK ITEMS ===== */
        .track-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 2px solid rgba(0, 212, 255, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .track-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(0, 212, 255, 0.3);
            transform: translateY(-1px);
        }
        
        .track-item:last-child {
            margin-bottom: 0;
        }
        
        .track-item.swipe-left {
            background: rgba(255, 107, 107, 0.2);
            border-color: rgba(255, 107, 107, 0.4);
            transform: translateX(-50px);
        }
        
        .track-item.blocked {
            background: rgba(255, 107, 107, 0.1);
            border-color: rgba(255, 107, 107, 0.3);
            opacity: 0.7;
        }
        
        .track-item.fav {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
        }
        
        .track-item.fav .track-title {
            color: #ffc107;
        }
        
        .block-indicator {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #ff6b6b;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .track-item.swipe-left .block-indicator {
            opacity: 1;
        }
        
        .track-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 6px;
            color: #00d4ff;
        }
        
        .track-details {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .track-bpm {
            font-weight: 500;
        }
        
        .track-mood {
            font-weight: 500;
            color: #ffd700;
        }
        
        /* ===== MODALS ===== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(5px);
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 15px;
            padding: 30px;
            min-width: 300px;
            max-width: 90vw;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: scale(0.9);
            transition: transform 0.2s;
        }
        
        .modal.show .modal-content {
            transform: scale(1);
        }
        
        .modal h3 {
            margin-bottom: 20px;
            color: #00d4ff;
            text-align: center;
        }
        
        .option-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .option-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 16px;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .option-item:hover {
            background: rgba(0, 212, 255, 0.3);
            color: white;
        }
        
        .option-item.remove-option {
            background: rgba(255, 107, 107, 0.2) !important;
            border: 1px solid rgba(255, 107, 107, 0.4) !important;
        }
        
        .search-modal .modal-content {
            width: 90%;
            max-width: 400px;
        }
        
        .search-input-modal {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 16px;
            margin-bottom: 20px;
            outline: none;
        }
        
        .search-results {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .no-results {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            padding: 20px;
        }
        
        /* ===== SCROLLBARS ===== */
        .results-container::-webkit-scrollbar,
        .search-results::-webkit-scrollbar {
            width: 6px;
        }
        
        .results-container::-webkit-scrollbar-track,
        .search-results::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .results-container::-webkit-scrollbar-thumb,
        .search-results::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.5);
            border-radius: 3px;
        }
        
        /* ===== MESSAGES ===== */
        .no-tracks-message {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            padding: 40px;
            font-size: 16px;
        }
        
        /* ===== ERROR STATES ===== */
        .error-state {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }
        
        /* ===== MOBILE RESPONSIVE ===== */
        @media (max-width: 768px) {
            .top-section {
                height: 50vh;
            }
            
            .bottom-section {
                height: 50vh;
            }
            
            .filter-bar {
                padding: 10px 15px;
                min-height: 40px;
            }
            
            .bar-label {
                font-size: 12px;
            }
            
            .bar-content {
                font-size: 14px;
            }
            
            .action-box {
                padding: 10px 15px;
                min-height: 40px;
            }
            
            .action-label {
                font-size: 9px;
            }
            
            .action-content {
                font-size: 11px;
            }
            
            .modal-content {
                margin: 20px;
                padding: 25px;
            }
        }

        /* ===== BUTTON STYLES ===== */
        .btn {
            background: linear-gradient(45deg, #00d4ff, #007bff);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
            margin-left: 10px;
            white-space: nowrap;
        }

        .btn:hover {
            background: linear-gradient(45deg, #007bff, #00d4ff);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 123, 255, 0.5);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
        }

        .btn:focus {
            outline: none;
        }

        /* PWA Install Prompt Styles */
        .pwa-install-prompt {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            background: linear-gradient(135deg, #00d4ff, #007bff);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3);
            z-index: 10000;
            display: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .pwa-install-prompt.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .install-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .install-btn {
            flex: 1;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .install-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .install-btn.install {
            background: rgba(255, 255, 255, 0.9);
            color: #1a1a2e;
        }
    </style>
</head>
<body>
    <!-- PWA Install Prompt -->
    <div class="pwa-install-prompt" id="pwaInstallPrompt">
        <div style="font-weight: 600; margin-bottom: 5px;">📱 Install DJ Mix Pro</div>
        <div style="font-size: 12px; opacity: 0.9; margin-bottom: 10px;">Add to home screen for the best experience!</div>
        <div class="install-buttons">
            <button class="install-btn" onclick="dismissInstallPrompt()">Later</button>
            <button class="install-btn install" onclick="installPWA()">Install</button>
        </div>
    </div>
    
    <!-- Export/Import Controls - REMOVED -->
    <div class="container">
        <!-- Top Section - Filter Bars + Dual Action Boxes -->
        <div class="top-section">
            <!-- Current Object / Search Bar -->
            <div class="filter-bar" id="currentObjectBar" data-action="search">
                <div class="bar-label">Current Track</div>
                <div class="bar-content" id="currentObjectContent">Tap to search for a track...</div>
            </div>
            
            <!-- PLACE Filter -->
            <div class="filter-bar" id="placeBar" data-action="place">
                <div class="bar-label">Place</div>
                <div class="bar-content" id="placeContent">Tap to select...</div>
            </div>
            
            <!-- MOOD Filter -->
            <div class="filter-bar" id="moodBar" data-action="mood">
                <div class="bar-label">Mood</div>
                <div class="bar-content" id="moodContent">Tap to select...</div>
            </div>
            
            <!-- STAR Filter -->
            <div class="filter-bar" id="starBar" data-action="star">
                <div class="bar-label">Star Rating</div>
                <div class="bar-content" id="starContent">Tap to select...</div>
            </div>
            
            <!-- Action Boxes -->
            <div class="action-container">
                <!-- RESET Box -->
                <div class="action-box reset-box" id="resetBox" data-action="reset">
                    <div class="action-label">Reset</div>
                    <div class="action-content" id="resetContent">
                        <span class="reset-icon">🔄</span>
                        <span>RESET</span>
                    </div>
                </div>
                
                <!-- UNDO Box -->
                <div class="action-box undo-box" id="undoBox" data-action="undo">
                    <div class="action-label">Undo</div>
                    <div class="action-content" id="undoContent">
                        <span class="undo-icon">↶</span>
                        <span>UNDO</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Bottom Section - Results -->
        <div class="bottom-section">
            <div class="results-container">
                <div class="results-header">Available Tracks</div>
                <div id="resultsList">
                    <div class="no-tracks-message">
                        Select filters (Place, Mood, Star) to see recommendations
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <!-- Search Modal -->
    <div class="modal" id="searchModal">
        <div class="modal-content search-modal">
            <h3>Search Tracks</h3>
            <input type="text" class="search-input-modal" id="searchInput" placeholder="Type track name..." autocomplete="off">
            <div class="search-results" id="searchResults"></div>
        </div>
    </div>

    <!-- PLACE Modal -->
    <div class="modal" id="placeModal">
        <div class="modal-content">
            <h3>Select Place</h3>
            <div class="option-list">
                <div class="option-item" data-value="OPEN">OPEN</div>
                <div class="option-item" data-value="STA">STA</div>
                <div class="option-item" data-value="MID">MID</div>
                <div class="option-item" data-value="END">END</div>
                <div class="option-item" data-value="CLOSE">CLOSE</div>
                <div class="option-item" data-value="ANY">ANY</div>
            </div>
        </div>
    </div>

    <!-- MOOD Modal -->
    <div class="modal" id="moodModal">
        <div class="modal-content">
            <h3>Select Mood</h3>
            <div class="option-list">
                <div class="option-item" data-value="SRS">SRS</div>
                <div class="option-item" data-value="JK">JK</div>
                <div class="option-item" data-value="BOTH">BOTH</div>
            </div>
        </div>
    </div>

    <!-- STAR Modal -->
    <div class="modal" id="starModal">
        <div class="modal-content">
            <h3>Select Star Rating</h3>
            <div class="option-list">
                <div class="option-item" data-value="5">⭐⭐⭐⭐⭐ (5)</div>
                <div class="option-item" data-value="4">⭐⭐⭐⭐ (4)</div>
                <div class="option-item" data-value="3">⭐⭐⭐ (3)</div>
                <div class="option-item" data-value="2">⭐⭐ (2)</div>
                <div class="option-item" data-value="1">⭐ (1)</div>
            </div>
        </div>
    </div>

    <script>
        // ===== APPLICATION STATE =====
        let appState = {
            tracks: [],
            currentTrack: null,
            previousTrack: null,
            selectedPlace: null,
            selectedMood: null,
            selectedStar: null,
            blockedTransitions: [],
            playedTracks: [],
            isInitialized: false
        };

        // ===== DEBUGGING & ERROR HANDLING =====
        function log(message, data = null) {
            console.log(`[DJ Mix System] ${message}`, data || '');
        }

        function handleError(error, context) {
            log(`ERROR in ${context}:`, error);
            showError(`Error in ${context}: ${error.message}`);
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-state';
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        // ===== DATA MANAGEMENT =====
        function loadTracks() {
            try {
                const savedTracks = localStorage.getItem('tracks');
                const savedBlocked = localStorage.getItem('blockedTransitions');
                
                appState.tracks = savedTracks ? JSON.parse(savedTracks) : getDefaultTracks();
                appState.blockedTransitions = savedBlocked ? JSON.parse(savedBlocked) : [];
                
                log('Tracks loaded successfully', appState.tracks.length);
            } catch (error) {
                handleError(error, 'loadTracks');
                appState.tracks = getDefaultTracks();
            }
        }

        function saveTracks() {
            try {
                localStorage.setItem('tracks', JSON.stringify(appState.tracks));
                localStorage.setItem('blockedTransitions', JSON.stringify(appState.blockedTransitions));
            } catch (error) {
                handleError(error, 'saveTracks');
            }
        }

        function getDefaultTracks() {
            return [
                { id: 1, title: "Opening Anthem", bpm: "128-135", key: "9A", toneless: "-", place: ["OPEN", "STA"], mood: ["SRS"], star: 3, fav: true },
                { id: 2, title: "Deep House Groove", bpm: "120-130", key: "8A", toneless: "-", place: ["ANY"], mood: ["DARK"], star: 4, fav: false },
                { id: 3, title: "Techno Blast", bpm: "135-145", key: "10A", toneless: "-", place: ["MID", "END"], mood: ["FUN"], star: 2, fav: false },
                { id: 4, title: "Melodic Journey", bpm: "125-135", key: "9B", toneless: "-", place: ["ANY", "CLOSE"], mood: ["SRS"], star: 1, fav: false },
                { id: 5, title: "Toneless Intro Track", bpm: "130-140", key: "9A", toneless: "T", place: ["STA", "MID", "OPEN"], mood: ["JK"], star: 4, fav: true },
                { id: 6, title: "Ambient Chill", bpm: "110-125", key: "7A", toneless: "-", place: ["MID", "END", "CLOSE"], mood: ["COOL"], star: 3, fav: false },
                { id: 7, title: "Club Banger", bpm: "135-145", key: "9A", toneless: "-", place: ["ANY"], mood: ["FUN"], star: 2, fav: false },
                { id: 8, title: "Closing Track", bpm: "125-140", key: "11B", toneless: "-", place: ["END", "CLOSE"], mood: ["DARK"], star: 1, fav: false },
                { id: 9, title: "Versatile Groove", bpm: "120-135", key: "8B", toneless: "O", place: ["STA", "ANY", "END"], mood: ["COOL"], star: 3, fav: false },
                { id: 10, title: "Perfect Opener", bpm: "130-140", key: "10A", toneless: "-", place: ["OPEN"], mood: ["JK"], star: 5, fav: true },
                { id: 11, title: "Ultimate Bridge", bpm: "125-140", key: "8A", toneless: "TO", place: ["MID", "END"], mood: ["FUN"], star: 4, fav: false }
            ];
        }

        // ===== EVENT HANDLING =====
        function initializeEventListeners() {
            try {
                log('Initializing event listeners...');
                
                // Single event delegation for all interactions
                document.addEventListener('click', handleGlobalClick);
                document.addEventListener('touchstart', handleGlobalTouch, { passive: false });
                
                // Keyboard events
                document.addEventListener('keydown', handleKeyDown);
                
                log('Event listeners initialized');
            } catch (error) {
                handleError(error, 'initializeEventListeners');
            }
        }

        function handleGlobalClick(event) {
            try {
                const target = event.target;
                
                // Handle filter bar clicks
                if (target.closest('.filter-bar')) {
                    const bar = target.closest('.filter-bar');
                    const action = bar.dataset.action;
                    handleBarClick(action);
                    return;
                }
                
                // Handle action box clicks
                if (target.closest('.action-box')) {
                    const box = target.closest('.action-box');
                    const action = box.dataset.action;
                    handleActionClick(action);
                    return;
                }
                
                // Handle modal option clicks
                if (target.closest('.option-item')) {
                    const option = target.closest('.option-item');
                    handleOptionClick(option);
                    return;
                }
                
                // Handle track item clicks
                if (target.closest('.track-item')) {
                    const trackItem = target.closest('.track-item');
                    const trackId = parseInt(trackItem.dataset.trackId);
                    log('Track item clicked:', trackId);
                    selectCurrentTrack(trackId);
                    return;
                }
                
                // Handle modal background clicks
                if (target.classList.contains('modal')) {
                    closeAllModals();
                    return;
                }
            } catch (error) {
                handleError(error, 'handleGlobalClick');
            }
        }

        function handleGlobalTouch(event) {
            try {
                const target = event.target;
                
                // Prevent zoom on double tap
                if (target.closest('.filter-bar') || target.closest('.action-box') || target.closest('.option-item') || target.closest('.track-item')) {
                    event.preventDefault();
                    handleGlobalClick(event);
                }
            } catch (error) {
                handleError(error, 'handleGlobalTouch');
            }
        }

        function handleKeyDown(event) {
            try {
                // Escape key closes modals
                if (event.key === 'Escape') {
                    closeAllModals();
                    return;
                }
                
                // Enter key in search input
                if (event.key === 'Enter' && document.activeElement.id === 'searchInput') {
                    const firstResult = document.querySelector('.search-results .option-item');
                    if (firstResult) {
                        const trackId = parseInt(firstResult.dataset.trackId);
                        selectCurrentTrack(trackId);
                        closeAllModals();
                    }
                }
            } catch (error) {
                handleError(error, 'handleKeyDown');
            }
        }

        // ===== UI INTERACTIONS =====
        function handleBarClick(action) {
            try {
                switch (action) {
                    case 'search':
                        openSearchModal();
                        break;
                    case 'place':
                        openModal('placeModal');
                        break;
                    case 'mood':
                        openModal('moodModal');
                        break;
                    case 'star':
                        openModal('starModal');
                        break;
                }
            } catch (error) {
                handleError(error, 'handleBarClick');
            }
        }

        function handleActionClick(action) {
            try {
                switch (action) {
                    case 'reset':
                        sessionReset();
                        break;
                    case 'undo':
                        undoTrackSelection();
                        break;
                }
            } catch (error) {
                handleError(error, 'handleActionClick');
            }
        }

        function handleOptionClick(option) {
            try {
                const modal = option.closest('.modal');
                const value = option.dataset.value;
                
                if (modal.id === 'searchModal') {
                    if (option.dataset.action === 'remove') {
                        clearCurrentTrack();
                    } else {
                        const trackId = parseInt(option.dataset.trackId);
                        selectCurrentTrack(trackId);
                    }
                } else if (modal.id === 'placeModal') {
                    appState.selectedPlace = value;
                    updateBarDisplay('placeBar', 'placeContent', value);
                    appState.selectedPlace && document.getElementById('placeBar').classList.add('active');
                } else if (modal.id === 'moodModal') {
                    appState.selectedMood = value;
                    updateBarDisplay('moodBar', 'moodContent', value);
                    appState.selectedMood && document.getElementById('moodBar').classList.add('active');
                } else if (modal.id === 'starModal') {
                    appState.selectedStar = parseInt(value);
                    updateBarDisplay('starBar', 'starContent', value + ' ⭐');
                    appState.selectedStar && document.getElementById('starBar').classList.add('active');
                }
                
                closeAllModals();
                updateResults();
            } catch (error) {
                handleError(error, 'handleOptionClick');
            }
        }

        function updateBarDisplay(barId, contentId, value) {
            const contentElement = document.getElementById(contentId);
            if (contentElement) {
                contentElement.textContent = value;
            }
        }

        // ===== MODAL MANAGEMENT =====
        function openSearchModal() {
            try {
                const modal = document.getElementById('searchModal');
                const input = document.getElementById('searchInput');
                
                input.value = '';
                filterSearchResults('');
                modal.classList.add('show');
                
                setTimeout(() => input.focus(), 100);
            } catch (error) {
                handleError(error, 'openSearchModal');
            }
        }

        function openModal(modalId) {
            try {
                const modal = document.getElementById(modalId);
                modal.classList.add('show');
            } catch (error) {
                handleError(error, 'openModal');
            }
        }

        function closeAllModals() {
            try {
                document.querySelectorAll('.modal').forEach(modal => {
                    modal.classList.remove('show');
                });
            } catch (error) {
                handleError(error, 'closeAllModals');
            }
        }

        // ===== TRACK MANAGEMENT =====
        function selectCurrentTrack(trackId) {
            try {
                log('Selecting track:', trackId);
                
                // Prevent page scrolling during track selection
                const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                
                const newTrack = appState.tracks.find(t => t.id === trackId);
                
                if (newTrack) {
                    log('Found track:', newTrack.title);
                    // Mark current track as played when moving to a new track
                    if (appState.currentTrack && appState.currentTrack.id !== newTrack.id) {
                        if (!appState.playedTracks.includes(appState.currentTrack.id)) {
                            appState.playedTracks.push(appState.currentTrack.id);
                            log('Track marked as played:', appState.currentTrack.title);
                        }
                    }
                    
                    if (appState.currentTrack) {
                        appState.previousTrack = appState.currentTrack;
                        document.getElementById('undoBox').classList.add('active');
                    }
                    
                    appState.currentTrack = newTrack;
                    document.getElementById('currentObjectContent').textContent = newTrack.title;
                    document.getElementById('currentObjectBar').classList.add('active');
                    
                    updateResults();
                    saveTracks();
                    
                    // Restore scroll position to prevent unwanted scrolling
                    setTimeout(() => {
                        window.scrollTo(0, currentScrollTop);
                    }, 0);
                    
                    log('Track selection complete');
                } else {
                    log('Track not found:', trackId);
                }
            } catch (error) {
                handleError(error, 'selectCurrentTrack');
            }
        }

        function clearCurrentTrack() {
            try {
                if (appState.currentTrack) {
                    appState.previousTrack = appState.currentTrack;
                    appState.currentTrack = null;
                    
                    document.getElementById('currentObjectContent').textContent = 'Tap to search for a track...';
                    document.getElementById('currentObjectBar').classList.remove('active');
                    document.getElementById('undoBox').classList.add('active');
                    
                    updateResults();
                }
            } catch (error) {
                handleError(error, 'clearCurrentTrack');
            }
        }

        function undoTrackSelection() {
            try {
                if (appState.previousTrack) {
                    appState.currentTrack = appState.previousTrack;
                    appState.previousTrack = null;
                    
                    document.getElementById('currentObjectContent').textContent = appState.currentTrack.title;
                    document.getElementById('undoBox').classList.remove('active');
                    
                    updateResults();
                }
            } catch (error) {
                handleError(error, 'undoTrackSelection');
            }
        }

        function sessionReset() {
            try {
                // Clear all selections
                appState.currentTrack = null;
                appState.previousTrack = null;
                appState.selectedPlace = null;
                appState.selectedMood = null;
                appState.selectedStar = null;
                
                // Update UI
                document.getElementById('currentObjectContent').textContent = 'Tap to search for a track...';
                document.getElementById('currentObjectBar').classList.remove('active');
                
                document.getElementById('placeContent').textContent = 'Tap to select...';
                document.getElementById('placeBar').classList.remove('active');
                
                document.getElementById('moodContent').textContent = 'Tap to select...';
                document.getElementById('moodBar').classList.remove('active');
                
                document.getElementById('starContent').textContent = 'Tap to select...';
                document.getElementById('starBar').classList.remove('active');
                
                document.getElementById('undoBox').classList.remove('active');
                
                // Update results
                updateResults();
            } catch (error) {
                handleError(error, 'sessionReset');
            }
        }

        // ===== SEARCH FUNCTIONALITY =====
        function filterSearchResults(query) {
            try {
                const resultsDiv = document.getElementById('searchResults');
                
                let html = '';
                
                // Add REMOVE option if there's a current track
                if (appState.currentTrack) {
                    html += `
                        <div class="option-item remove-option" data-action="remove">
                            <strong>REMOVE</strong> - Clear current track selection
                        </div>
                    `;
                }
                
                if (query.length === 0) {
                    html += '<div class="no-results">Type to search tracks...</div>';
                    resultsDiv.innerHTML = html;
                    return;
                }
                
                const filtered = appState.tracks.filter(track => 
                    track.title.toLowerCase().includes(query.toLowerCase())
                );
                
                if (filtered.length === 0) {
                    html += '<div class="no-results">No tracks found</div>';
                    resultsDiv.innerHTML = html;
                    return;
                }
                
                html += filtered.map(track => `
                    <div class="option-item" data-track-id="${track.id}">
                        <div style="text-align: left;">
                            <div style="font-weight: bold; color: #00d4ff;">${track.title}</div>
                            <div style="font-size: 12px; color: rgba(255,255,255,0.7);">
                                BPM: ${track.bpm} | Key: ${track.key}
                            </div>
                        </div>
                    </div>
                `).join('');
                
                resultsDiv.innerHTML = html;
            } catch (error) {
                handleError(error, 'filterSearchResults');
            }
        }

        // ===== RESULTS MANAGEMENT =====
        function updateResults() {
            try {
                const resultsList = document.getElementById('resultsList');
                
                // Allow browsing without current track
                if (!appState.selectedPlace || !appState.selectedMood || !appState.selectedStar) {
                    resultsList.innerHTML = '<div class="no-tracks-message">Select all filters (Place, Mood, Star) to see recommendations</div>';
                    return;
                }
                
                const recommendations = filterTracks();
                
                if (recommendations.length === 0) {
                    resultsList.innerHTML = '<div class="no-tracks-message">No tracks match your criteria</div>';
                    return;
                }
                
                // Sort FAV tracks first, then randomize the rest
                const sorted = [...recommendations].sort((a, b) => {
                    if (a.fav && !b.fav) return -1;
                    if (!a.fav && b.fav) return 1;
                    return Math.random() - 0.5;
                });
                
                resultsList.innerHTML = sorted.map(track => {
                    const isBlocked = appState.currentTrack ? isTransitionBlocked(appState.currentTrack.id, track.id) : false;
                    return `
                        <div class="track-item ${isBlocked ? 'blocked' : ''} ${track.fav ? 'fav' : ''}" data-track-id="${track.id}">
                            <div class="block-indicator">🚫</div>
                            <div class="track-title">${track.title}${track.fav ? ' ⭐' : ''}</div>
                            <div class="track-details">
                                <span class="track-bpm">BPM: ${track.bpm} | Key: ${track.key}${track.toneless !== '-' ? ` (${track.toneless})` : ''}</span>
                                <span class="track-mood">MOOD: ${track.mood.join(', ')}</span>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Add swipe handlers for track items
                resultsList.querySelectorAll('.track-item').forEach(item => {
                    addSwipeHandler(item, parseInt(item.dataset.trackId));
                });
            } catch (error) {
                handleError(error, 'updateResults');
            }
        }

        // ===== TRACK FILTERING =====
        function filterTracks() {
            try {
                return appState.tracks.filter(track => {
                    // Don't recommend the currently playing track
                    if (appState.currentTrack && track.id === appState.currentTrack.id) return false;
                    
                    // Check if this transition is blocked
                    if (appState.currentTrack && isTransitionBlocked(appState.currentTrack.id, track.id)) return false;
                    
                    // BPM range overlap check
                    if (appState.currentTrack && !bpmRangesOverlap(appState.currentTrack.bpm, track.bpm)) return false;
                    
                    // Key compatibility check
                    if (appState.currentTrack && !keysCompatible(appState.currentTrack, track)) return false;
                    
                    // PLACE match
                    if (!placeMatches(track.place)) return false;
                    
                    // MOOD match
                    if (!moodMatches(track.mood)) return false;
                    
                    // STAR rating - Show tracks with star rating >= selected star
                    if (track.star < appState.selectedStar) return false;
                    
                    return true;
                });
            } catch (error) {
                handleError(error, 'filterTracks');
                return [];
            }
        }

        function bpmRangesOverlap(range1, range2) {
            const [min1, max1] = range1.split('-').map(Number);
            const [min2, max2] = range2.split('-').map(Number);
            return max1 >= min2 && max2 >= min1;
        }

        function keysCompatible(currentTrack, candidateTrack) {
            const currentKey = currentTrack.key;
            const currentToneless = currentTrack.toneless;
            const candidateKey = candidateTrack.key;
            const candidateToneless = candidateTrack.toneless;
            
            // If candidate track has toneless intro (T), it can mix with ANY current track
            if (candidateToneless === 'T') return true;
            
            // If current track has toneless outro (O), it can mix with ANY candidate track
            if (currentToneless === 'O') return true;
            
            // If either track has toneless intro & outro (TO), they can mix with anything
            if (currentToneless === 'TO' || candidateToneless === 'TO') return true;
            
            // If either track has no key data (-), assume incompatible for safety
            if (currentToneless === '-' && !currentKey) return false;
            if (candidateToneless === '-' && !candidateKey) return false;
            
            // Both have standard musical keys - check Camelot compatibility
            return areCamelotKeysCompatible(currentKey, candidateKey);
        }

        function areCamelotKeysCompatible(key1, key2) {
            const parseCamelotKey = (key) => {
                const match = key.match(/(\d+)([AB])/);
                if (!match) return null;
                return { number: parseInt(match[1]), letter: match[2] };
            };
            
            const k1 = parseCamelotKey(key1);
            const k2 = parseCamelotKey(key2);
            
            if (!k1 || !k2) return false;
            
            // Same key
            if (k1.number === k2.number && k1.letter === k2.letter) return true;
            
            // Energy boost: +1 semitone (same letter)
            if (k1.number + 1 === k2.number && k1.letter === k2.letter) return true;
            
            // Energy drop: -1 semitone (same letter)  
            if (k1.number - 1 === k2.number && k1.letter === k2.letter) return true;
            
            // Dominant relationship: same number, opposite letter
            if (k1.number === k2.number && k1.letter !== k2.letter) return true;
            
            // Handle wraparound
            if (k1.number === 12 && k2.number === 1 && k1.letter === k2.letter) return true;
            if (k1.number === 1 && k2.number === 12 && k1.letter === k2.letter) return true;
            
            return false;
        }

        function placeMatches(trackPlaces) {
            // If the track has ANY tag, it matches STA, MID, or END selections
            if (trackPlaces.includes('ANY')) {
                if (['STA', 'MID', 'END'].includes(appState.selectedPlace)) {
                    return true;
                }
            }
            
            // Check if the track has the specifically selected place
            return trackPlaces.includes(appState.selectedPlace);
        }

        function moodMatches(trackMoods) {
            // SRS filter shows: SRS, DARK, FUN tracks
            if (appState.selectedMood === 'SRS') {
                return trackMoods.some(mood => ['SRS', 'DARK', 'FUN'].includes(mood));
            }
            
            // JK filter shows: JK, COOL, FUN tracks
            if (appState.selectedMood === 'JK') {
                return trackMoods.some(mood => ['JK', 'COOL', 'FUN'].includes(mood));
            }
            
            // BOTH filter shows: ALL tracks with any mood
            if (appState.selectedMood === 'BOTH') {
                return trackMoods.length > 0;
            }
            
            return false;
        }

        function isTransitionBlocked(fromTrackId, toTrackId) {
            const transition = `${fromTrackId}-${toTrackId}`;
            return appState.blockedTransitions.includes(transition);
        }

        // ===== SWIPE HANDLING =====
        function addSwipeHandler(element, trackId) {
            let startX = 0;
            let startY = 0;
            let isSwipe = false;
            
            element.addEventListener('touchstart', function(e) {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isSwipe = false;
            });
            
            element.addEventListener('touchmove', function(e) {
                if (!startX || !startY) return;
                
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const diffX = startX - currentX;
                const diffY = startY - currentY;
                
                // Check if it's a horizontal swipe (more horizontal than vertical)
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
                    isSwipe = true;
                    
                    if (diffX > 0) { // Swipe left
                        this.classList.add('swipe-left');
                    } else { // Swipe right
                        this.classList.remove('swipe-left');
                    }
                }
            });
            
            element.addEventListener('touchend', function(e) {
                if (isSwipe && this.classList.contains('swipe-left')) {
                    // Block this transition (only if there's a current track)
                    if (appState.currentTrack) {
                        blockTransition(appState.currentTrack.id, trackId);
                        this.classList.remove('swipe-left');
                        this.classList.add('blocked');
                        
                        // Show brief feedback
                        setTimeout(() => {
                            updateResults(); // Refresh to hide blocked track
                        }, 500);
                    }
                } else {
                    // Reset swipe state
                    this.classList.remove('swipe-left');
                }
                
                startX = 0;
                startY = 0;
                isSwipe = false;
            });
        }

        function blockTransition(fromTrackId, toTrackId) {
            const transition = `${fromTrackId}-${toTrackId}`;
            
            if (!appState.blockedTransitions.includes(transition)) {
                appState.blockedTransitions.push(transition);
                saveTracks();
            }
        }

        // ===== SEARCH INPUT HANDLING =====
        function initializeSearchInput() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    filterSearchResults(this.value);
                });
            }
        }

        // ===== INITIALIZATION =====
        function initializeApp() {
            try {
                log('🎵 DJ Mix System - PROFESSIONAL EDITION 🎵');
                log('Initializing complete PWA feature set...');
                
                // Load data
                loadTracks();
                
                // Setup event listeners
                initializeEventListeners();
                initializeSearchInput();
                
                // Check for install prompt dismissal
                const dismissedTime = localStorage.getItem('installPromptDismissed');
                if (dismissedTime) {
                    const hoursSinceDismissed = (Date.now() - parseInt(dismissedTime)) / (1000 * 60 * 60);
                    if (hoursSinceDismissed < 24) {
                        installPromptShown = true; // Don't show again
                    }
                }
                
                // Initial UI update
                updateResults();
                
                appState.isInitialized = true;
                log('✅ DJ Mix PWA fully initialized!');
                log('Features loaded: PWA support, Offline mode, Enhanced iOS integration');
                
            } catch (error) {
                handleError(error, 'initializeApp');
                showError('❌ Failed to initialize the application. Please refresh the page.');
            }
        }

        // Start the application
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        // Fallback initialization in case DOMContentLoaded doesn't fire
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(initializeApp, 100);
        }

        // ===== EXPORT/IMPORT FUNCTIONS =====
        function exportData() {
            try {
                const data = JSON.stringify(appState, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'dj_mix_system_data.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                log('Data exported successfully.');
            } catch (error) {
                handleError(error, 'exportData');
                showError('Failed to export data.');
            }
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            if (importedData && importedData.tracks && importedData.blockedTransitions) {
                                appState.tracks = importedData.tracks;
                                appState.blockedTransitions = importedData.blockedTransitions;
                                saveTracks(); // Save immediately after import
                                log('Data imported successfully.');
                                updateResults(); // Refresh results with new data
                            } else {
                                showError('Invalid import file format.');
                            }
                        } catch (error) {
                            handleError(error, 'importData');
                            showError('Failed to import data: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        // ===== PWA INSTALLATION =====
        let deferredPrompt;
        let installPromptShown = false;
        
        // Register service worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('[SW] Registered successfully:', registration.scope);
                        
                        // Handle service worker updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New version available
                                    showUpdateNotification();
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.log('[SW] Registration failed:', error);
                    });
            });
        }
        
        // Handle PWA install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install prompt after a short delay and some user interaction
            if (!installPromptShown && appState.isInitialized) {
                setTimeout(() => {
                    showInstallPrompt();
                }, 3000);
            }
        });
        
        // Handle successful installation
        window.addEventListener('appinstalled', () => {
            console.log('[PWA] App installed successfully');
            hideInstallPrompt();
            deferredPrompt = null;
        });
        
        function showInstallPrompt() {
            if (deferredPrompt && !installPromptShown) {
                document.getElementById('pwaInstallPrompt').classList.add('show');
                installPromptShown = true;
            }
        }
        
        function hideInstallPrompt() {
            document.getElementById('pwaInstallPrompt').classList.remove('show');
        }
        
        function dismissInstallPrompt() {
            hideInstallPrompt();
            // Don't show again for 24 hours
            localStorage.setItem('installPromptDismissed', Date.now().toString());
        }
        
        function installPWA() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('[PWA] User accepted install prompt');
                    } else {
                        console.log('[PWA] User dismissed install prompt');
                    }
                    deferredPrompt = null;
                    hideInstallPrompt();
                });
            }
        }
        
        function showUpdateNotification() {
            // Show a subtle notification about app update
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 20px;
                right: 20px;
                background: linear-gradient(135deg, #00d4ff, #007bff);
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10000;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                animation: slideDown 0.3s ease-out;
            `;
            notification.innerHTML = `
                <div style="font-weight: 600;">🔄 Update Available</div>
                <div style="font-size: 12px; opacity: 0.9;">New version ready. Refresh to update.</div>
                <button onclick="location.reload()" style="
                    margin-top: 8px;
                    background: rgba(255, 255, 255, 0.2);
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    color: white;
                    padding: 6px 12px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 12px;
                ">Update Now</button>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 10000);
        }
    </script>
</body>
</html>
